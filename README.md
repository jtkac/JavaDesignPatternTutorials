# JavaDesignPatternTutorials

Java is advantageous over Kotlin and React in the case where you are required to operate offline and are dealing with databases and data storage. Kotlin, because of a repeatable work-related defect in Java, adds a base reflection time to processing transport languages (such as JSON or XML) which, in Java, amounts to .004 additional seconds per record. Kotlin solves this by applying the fastest reflection time available. Java can still be used to explicitly declare what to expect from transport languages which gets rid of the times associated with Kotlin's reflection. Given we are dealing with a few records up to about 100,000 this time may seem unnoticable. There does however exist a niche case which correlates to records beyond 100,000 where reflection may be optimally refactored out by reverting Kotlin to Java in offline based environments.

Given we are reverting back to Java, I spent some time compiling a list of the best or free-est or, in the case of databases, quickest but potentially paid additions respective of traditional Java lifecycle.

In the age of LLMs having a design pattern is important. For these examples, I chose a cache mechanism that populates into a user-interface when the context is guaranteed and to refresh when the app is minimized. The cache system is complimented by a connectable view interface system which declares methods that will call back to an Activity or Fragment alongside the various capabilities of that activity or fragment. Finally we include a service layer to encapsulate any suppliable micro-services or recursive utilities. This design pattern is particularly useful as we can configure most of the results to be displayed in RX Java. RX Java obfuscates the identifiers against various UI automation utilities (manual or machine driven). What was missing was the obfuscation for recycler views from these examples. We would otherwise annotate this as @BindableAdapter however it is less fluent than wrapping the item in a layout tag due to the recursive nature of XML as a transport language. eg. We may make a textview in a transport language and use it 10 times in 10 unique adapters. I suppose we could preplan 10 different data tags but this may turn into an N+1 kind of problem. In reality if a user decided to analyze using automation utilities, they would still be able to retrieve from a recycler adapter to a point of loading before the recycler would have to be manually scrolled to automate viewing the rest. Aside from this small defect, a Java app becomes very difficult for UI automation utilities that are not inherently within the testing framework to access and peruse the UI.

Given the various server frameworks I may consume from a networkable supplier service may be consumed by either Java, Kotlin, or a hybrid Android / iOS system, the real factor to consider would be reflection. If I have a lot of records to store, reflection is a base time added. If I can always count on having internet instead of intranet, Java is not the superior option. The hybrid option was limiting though if it implements Realm as it's database system, I would consider the base numerical operand reduction of Realm to be advantageous.

If I would have wanted to refactor out something arbitrary like an ORM with a modern LLM plug in setup, I would simply create a custom annotatable, apply the annotation to a data layer object, plugin a base one shot and stop button server, and code an LLM to look at the annotation for a corresponding data field and combine a production ready database driver. This would be the free-est setup I could think of given a data storage mechanism exists.
